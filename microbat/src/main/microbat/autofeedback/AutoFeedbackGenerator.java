package microbat.autofeedback;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.swt.widgets.Display;

import microbat.Activator;
import microbat.baseline.encoders.ProbabilityEncoder;
import microbat.model.trace.Trace;
import microbat.model.trace.TraceNode;
import microbat.model.value.VarValue;
import microbat.model.variable.VirtualVar;
import microbat.preference.MicrobatPreference;
import microbat.recommendation.ChosenVariableOption;
import microbat.recommendation.UserFeedback;
import microbat.stepvectorizer.StepVector;
import microbat.stepvectorizer.StepVectorizer;
import microbat.views.DebugFeedbackView;
import microbat.views.MicroBatViews;


/**
 * AutoFeedback Generator will generate feedback for selected trace node using the selected method
 * @author David
 */
public class AutoFeedbackGenerator {

	public static UserFeedback staticPrevFeedback = null;
	
	// Method selected to generate the feedback
	private AutoFeedbackMethods selectedMethod;
	
	// Feedback of previous trace node. Used in NAIVE method
	private UserFeedback prevFeedback;
	
	// Constructor
	public AutoFeedbackGenerator() {
		this.selectedMethod = null;
		this.prevFeedback = null;
	}
	
	/**
	 * Give feedback for the given trace node based on selected method
	 * @param traceNode Trace node to be commended
	 * @param buggyTrace Trace that the given trace node belongs
	 * @return Feedback of the trace node. Can be null.
	 */
	public UserFeedback giveFeedback(TraceNode traceNode, Trace buggyTrace) {
		this.selectedMethod = this.getMethod();
		
		switch(this.selectedMethod) {
		case BASELINE:
			this.prevFeedback = this.giveBaselineFeedback(traceNode, buggyTrace);
			break;
		case MACHINE_LEARNING:
			this.prevFeedback = this.giveMLFeedback(traceNode, buggyTrace);
			break;
		case NAIVE:
			this.prevFeedback = this.giveNaiveFeedback(traceNode);
			break;
		case RANDOM:
			this.prevFeedback = this.giveRandomFeedback(traceNode, buggyTrace);
			break;
		default:
			break;
		}
		return this.prevFeedback;
	}
	
	// Get the selected method from the preference page
	public AutoFeedbackMethods getMethod() {
		String selectedMethodName = Activator.getDefault().getPreferenceStore().getString(MicrobatPreference.AUTO_FEEDBACK_METHOD);
		AutoFeedbackMethods selectedMethod = AutoFeedbackMethods.valueOf(selectedMethodName);
		return selectedMethod;
	}
	
	// Temporary implementation for baseline.
	public TraceNode getBaselineResultNode(Trace trace) {
		ProbabilityEncoder pe = new ProbabilityEncoder(trace);
		pe.setup();
		pe.encode();
		return pe.getMostErroneousNode();
	}
	
	private UserFeedback giveMLFeedback(TraceNode targetNode, Trace trace) {
		// Test it in exp2
		UserFeedback feedback = new UserFeedback();
		
		StepVectorizer vectorizer = new StepVectorizer(trace);
		
		ModelClient client = new ModelClient();
		String input_vec = vectorizer.vectorize(154-1).convertToCSV();
		String ref_vec = vectorizer.vectorize(155-1).convertToCSV();
		System.out.println(input_vec);
		System.out.println(ref_vec);
		
		System.out.println(client.requestClassification(input_vec, ref_vec));
		return null;
	}
	
	
	/**
	 * Give feedback based on the previous feedback
	 * @param traceNode Trace node that to be commended
	 * @return Feedback of the traceNode. Can be null.
	 */
	private UserFeedback giveNaiveFeedback(TraceNode traceNode) {
		
		// Directly use the previous feedback if exist. If not, then extract the feedback from the feedback view
		if (this.prevFeedback == null) {
			Display.getDefault().syncExec(new Runnable() {
				@Override
				public void run() {
					DebugFeedbackView feedbackView = MicroBatViews.getDebugFeedbackView();
					UserFeedback feedback = feedbackView.getFeedback();
					AutoFeedbackGenerator.setPrevFeedback(feedback);
				}
			});
			this.prevFeedback = AutoFeedbackGenerator.staticPrevFeedback;
		}
		
		// Cannot directly use the prevFeedback if it is data incorrect
		if(this.prevFeedback.getFeedbackType() == null) {
			System.out.println("Please provide initial feedback before using NAIVE approach.");
			return null;
		}
		
		UserFeedback feedback = new UserFeedback();
		if(this.prevFeedback.getFeedbackType() == UserFeedback.WRONG_VARIABLE_VALUE) {
			List<VarValue> readVars = traceNode.getReadVariables();
			readVars = this.removeVarsGenByJava(readVars);	// Remove variables that is generated by java
			if (readVars.isEmpty()) {
				feedback.setFeedbackType(UserFeedback.WRONG_PATH);
				this.printFeedbackMessage(traceNode, feedback, null);
			} else {
				// Select random variable to be wrong
				VarValue wrongVar = this.getRandVar(readVars, true);
				// Construct new feedback
				ChosenVariableOption option = new ChosenVariableOption(wrongVar, null);
				feedback.setFeedbackType(UserFeedback.WRONG_VARIABLE_VALUE);
				feedback.setOption(option);
				this.printFeedbackMessage(traceNode, feedback, wrongVar);
			}
		} else {
			feedback.setFeedbackType(UserFeedback.WRONG_PATH);
			this.printFeedbackMessage(traceNode, feedback, null);
		}
		return feedback;
	}
	
	// Give feedback based on baseline approach
	private UserFeedback giveBaselineFeedback(TraceNode traceNode, Trace buggyTrace) {
		UserFeedback feedback = new UserFeedback();
		
		// Run baseline approach to get probability
		ProbabilityEncoder pe = new ProbabilityEncoder(buggyTrace);
		pe.setup();
		pe.encode();
		
		// If the probability of being correct is more than 0.75, then we assume it to be correct
		double correctThreshold = 0.75;
		
		// Check if the trace node is correct or not
		if (traceNode.getProbability() > correctThreshold) {
			feedback.setFeedbackType(UserFeedback.CORRECT);
			this.printFeedbackMessage(traceNode, feedback, null);
			return feedback;
		}
		
		// Now the trace node is wrong
		// Get the read variable with highest probability to be wrong
		// If all the read variable is correct, then this trace node should be control incorrect.
		List<VarValue> readVars = traceNode.getReadVariables();
		VarValue wrongVar = null;
		double minProb = correctThreshold;
		for (VarValue readVar: readVars) {
			if (readVar.getProbability() < minProb) {
				wrongVar = readVar;
				minProb = readVar.getProbability();
			}
		}
		
		if (wrongVar == null) {
			feedback.setFeedbackType(UserFeedback.WRONG_PATH);
			this.printFeedbackMessage(traceNode, feedback, null);
			return feedback;
		} else {
			feedback.setFeedbackType(UserFeedback.WRONG_VARIABLE_VALUE);
			ChosenVariableOption option = new ChosenVariableOption(wrongVar, null);
			feedback.setOption(option);
			this.printFeedbackMessage(traceNode, feedback, wrongVar);
			return feedback;
		}
	}
	
	/**
	 * Give random feedback for the given trace node.
	 * It will not give UNCLEAR feedback.
	 * It will not give CORRECT feedback to the last trace node, which is assumed to be wrong.
	 * @param traceNode Trace node that to be commended
	 * @param trace Trace that the trace node belong
	 * @return Feedback of the given trace node
	 */
	private UserFeedback giveRandomFeedback(TraceNode traceNode, Trace trace) {
		UserFeedback feedback = new UserFeedback();
		
		// Decide if the trace node correct or not. If the trace node is the last node in trace,
		// then it should not be correct
		if (traceNode != trace.getLatestNode()) {
			if (this.guessIsCorrect()) {
				feedback.setFeedbackType(UserFeedback.CORRECT);
				this.printFeedbackMessage(traceNode, feedback, null);
				return feedback;
			}
		}
		
		// Now the trace node is wrong
		// Decide if the trace node control incorrect or data incorrect
		// Note that if this trace node do not have any reading variable then it must be control incorrect
		List<VarValue> readVars = traceNode.getReadVariables();
		
		// Do not count the temporary variable generated by java
		readVars = this.removeVarsGenByJava(readVars);
		if (readVars.isEmpty() || this.guessIsControlIncorrect()) {
			feedback.setFeedbackType(UserFeedback.WRONG_PATH);
			this.printFeedbackMessage(traceNode, feedback, null);
			return feedback;
		}
		
		// Pick one variable to be wrong
		VarValue wrongVar = this.getRandVar(readVars, true);
		feedback.setFeedbackType(UserFeedback.WRONG_VARIABLE_VALUE);
		ChosenVariableOption option = new ChosenVariableOption(wrongVar, null);
		feedback.setOption(option);
		this.printFeedbackMessage(traceNode, feedback, wrongVar);
		return feedback;		
	}
	
	/**
	 * Pick a random variable form give list of variable
	 * @param vars	List of variable
	 * @param bias	If true, then variable will prefer to pick the variable that is return from a function call
	 * @return Selected variable from list
	 */
	private VarValue getRandVar(List<VarValue> vars, boolean bias) {
		if (bias) {
			for(VarValue var: vars) {
				// If the variable is returned from function call, then it is the instance of VirtualVar
				if(var.getVariable() instanceof VirtualVar) {
					if(Math.random() > 0.2) {
						return var;
					}
				}
			}
		}
		int wrongVarIdx = this.getRandomInt(0, vars.size());
		return vars.get(wrongVarIdx);
	}
	
	/**
	 * Get random integer
	 * @param min Lower bound
	 * @param max Upper bound
	 * @return Random integer in range [min, max)
	 */
	private int getRandomInt(int min, int max) {
		return (int) ((Math.random() * (max - min)) + min);
	}
	
	/**
	 * Remove the variables generated by Java from list
	 * @param vars Input variable list
	 * @return List of variable without variable generated by Java
	 */
	private List<VarValue> removeVarsGenByJava(List<VarValue> input) {
		// Deep copy
		List<VarValue> vars = new ArrayList<VarValue>();
		vars.addAll(input);
		
		// Do not count the temporary variable generated by java
		for (int i=0; i<vars.size(); ++i) {
			VarValue var = vars.get(i);
			String var_id = var.getVarID();
			if(var_id.startsWith("java.")) {
				vars.remove(i);
				i--;
			}
		}
		return vars;
	}
	
	/**
	 * Randomly guess is the statement correct or not
	 * @return True if the statement is correct
	 */
	private boolean guessIsCorrect() {
		return Math.random() > 0.9;
	}
	
	/**
	 * Randomly guess is the statement control incorrect or not
	 * @return True if the statement is control incorrect
	 */
	private boolean guessIsControlIncorrect() {
		return Math.random() > 0.9;
	}
	
	public static void setPrevFeedback(UserFeedback feedback) {
		AutoFeedbackGenerator.staticPrevFeedback = feedback;
	}
	
	private void printFeedbackMessage(TraceNode node, UserFeedback feedback, VarValue wrongVar) {
		switch(feedback.getFeedbackType()) {
		case UserFeedback.CORRECT:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is correct.");
			return;
		case UserFeedback.WRONG_PATH:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is control incorrect.");
			return;
		case UserFeedback.WRONG_VARIABLE_VALUE:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is data incorrect with wrong variable " + wrongVar.getVarName());
			return;
		case UserFeedback.UNCLEAR:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is unclear");
			return;
			default:
				return;
		}
	}
}
